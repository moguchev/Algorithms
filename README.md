# Algorithms
Алгоритмы и структуры данных. Технопарк mail.ru 2019г.

## Модуль 1. Базовые алгоритмы и структуры данных.
	* 1_2. Вычислить площадь выпуклого n-угольника, заданного координатами своих вершин.
	Вначале вводится количество вершин, затем последовательно целочисленные координаты 
	всех вершин в порядке обхода против часовой стрелки. n < 1000, координаты < 10000.
	Указание. Для вычисления площади n-угольника можно посчитать сумму ориентированных
	площадей трапеций под каждой стороной многоугольника.
	|in |out|
	|---|---|
	|3  |1.5|
	|0 1|   |
	|1 0|   |
	|2 2|   |
	* 2_1. Дан отсортированный массив целых чисел A[0..n-1] и массив целых чисел B[0..m-1].
	Для каждого элемента массива B[i] найдите минимальный индекс k минимального элемента
	массива A, равного или превосходящего B[i]: A[k] >= B[i]. Если такого элемента нет, 
	выведите n. Время работы поиска k для каждого элемента B[i]: O(log(k)). n, m ≤ 10000.
	Формат входных данных.
	В первой строчке записаны числа n и m. Во второй и третьей массивы A и B соответственно.
	* 3_1. Реализовать очередь с динамическим зацикленным буфером.
	Cледует написать структуру данных, обрабатывающую команды push* и pop*.
	Формат входных данных.
	В первой строке количество команд n. n ≤ 1000000.
	Каждая команда задаётся как 2 целых числа: a b.
	a = 1 - push front
	a = 2 - pop front
	a = 3 - push back
	a = 4 - pop back
	Команды добавления элемента 1 и 3 заданы с неотрицательным параметром b.
	Для очереди используются команды 2 и 3. Для дека используются все четыре команды.
	Если дана команда pop*, то число b - ожидаемое значение. Если команда pop вызвана
	для пустой структуры данных, то ожидается “-1”. 
	Формат выходных данных.
	Требуется напечатать YES - если все ожидаемые значения совпали. Иначе, если хотя
	бы одно ожидание не оправдалось, то напечатать NO.
	* 4_2. Быстрое сложение.
	Для сложения чисел используется старый компьютер. Время, затрачиваемое на нахождение
	суммы двух чисел равно их сумме. Таким образом для нахождения суммы чисел 1,2,3 может
	потребоваться разное время, в зависимости от порядка вычислений.
	((1+2)+3) -> 1+2 + 3+3 = 9
	((1+3)+2) -> 1+3 + 4+2 = 10
	((2+3)+1) -> 2+3 + 5+1 = 11
	Требуется написать программу, которая определяет минимальное время, достаточное для
	вычисления суммы заданного набора чисел.
	Формат входных данных. Вначале вводится n - количество чисел. Затем вводится n строк - 
	значения чисел (значение каждого числа не превосходит 10^9, сумма всех чисел не превосходит 2*10^9).
	Формат выходных данных. Натуральное число - минимальное время.
	* 5_4. Закраска прямой 2.
	На числовой прямой окрасили N отрезков. Известны координаты левого и правого концов каждого отрезка
	(Li и Ri). Найти сумму длин частей числовой прямой, окрашенных ровно в один слой.
	* 6_3. Реализуйте стратегию выбора опорного элемента “случайный элемент”. Функцию Partition реализуйте 
	методом прохода двумя итераторами от начала массива к концу.
	* 7_2. LSD для long long.
	Дан массив неотрицательных целых 64-битных чисел. Количество чисел не больше 106.
	Отсортировать массив методом поразрядной сортировки LSD по байтам.

## Модуль 2. Хеш-таблицы. Деревья.
	* 1_2. Реализуйте структуру данных типа “множество строк” на основе динамической хеш-таблицы с
	открытой адресацией. Хранимые строки непустые и состоят из строчных латинских букв.
	Хеш-функция строки должна быть реализована с помощью вычисления значения многочлена методом Горнера.
	Начальный размер таблицы должен быть равным 8-ми. Перехеширование выполняйте при добавлении элементов
	в случае, когда коэффициент заполнения таблицы достигает 3/4.
	Структура данных должна поддерживать операции добавления строки в множество, удаления строки из
	множества и проверки принадлежности данной строки множеству.
	Для разрешения коллизий используйте двойное хеширование.
	Формат входных данных
	Каждая строка входных данных задает одну операцию над множеством. Запись операции состоит из типа операции
	и следующей за ним через пробел строки, над которой проводится операция.
	Тип операции  – один из трех символов:
    	"+"  означает добавление данной строки в множество; 
    	"-"  означает удаление  строки из множества;  
    	"?"  означает проверку принадлежности данной строки множеству. 
	При добавлении элемента в множество НЕ ГАРАНТИРУЕТСЯ, что он отсутствует в этом множестве. При удалении
	элемента из множества НЕ ГАРАНТИРУЕТСЯ, что он присутствует в этом множестве.
	Формат выходных данных
	Программа должна вывести для каждой операции одну из двух строк OK или FAIL, в зависимости от того,
	встречается ли данное слово в нашем множестве.
	* 2_1. Дано число N < 106 и последовательность целых чисел из [-231..231] длиной N.
	Требуется построить бинарное дерево, заданное наивным порядком вставки.
	Т.е., при добавлении очередного числа K в дерево с корнем root, если root→Key ≤ K, то узел K добавляется
	в правое поддерево root; иначе в левое поддерево root. Рекурсия запрещена.
	Выведите элементы в порядке in-order (слева направо).
	Дано число N < 106 и последовательность пар целых чисел из [-231..231] длиной N.
	* 3_1. Построить декартово дерево из N узлов, характеризующихся парами чисел {Xi, Yi}.
	Каждая пара чисел {Xi, Yi} определяет ключ Xi и приоритет Yi в декартовом дереве.
	Добавление узла в декартово дерево выполняйте второй версией алгоритма, рассказанного на лекции:
	При добавлении узла (x, y) выполняйте спуск по ключу до узла P с меньшим приоритетом. Затем разбейте найденное
	поддерево по ключу x так, чтобы в первом поддереве все ключи меньше x, а во втором больше или равны x. Получившиеся
	два дерева сделайте дочерними для нового узла (x, y). Новый узел вставьте на место узла P.
	Построить также наивное дерево поиска по ключам Xi методом из задачи 2.
	Вычислить разницу глубин наивного дерева поиска и декартового дерева. Разница может быть отрицательна.
	* 4_1. Солдаты. В одной военной части решили построить в одну шеренгу по росту. Т.к. часть была далеко не образцовая, то
	солдаты часто приходили не вовремя, а то их и вовсе приходилось выгонять из шеренги за плохо начищенные сапоги. Однако
	солдаты в процессе прихода и ухода должны были всегда быть выстроены по росту – сначала самые высокие, а в конце – самые низкие.
	За расстановку солдат отвечал прапорщик, который заметил интересную особенность – все солдаты в части разного роста. Ваша задача
	состоит в том, чтобы помочь прапорщику правильно расставлять солдат, а именно для каждого приходящего солдата указывать, перед
	каким солдатом в строе он должен становится. Требуемая скорость выполнения команды - O(log n).
	Формат входных данных.
	Первая строка содержит число N – количество команд (1 ≤ N ≤ 30 000). В каждой следующей строке содержится описание команды: число 1 и X
	если солдат приходит в строй (X – рост солдата, натуральное число до 100 000 включительно) и число 2 и Y если солдата, стоящим в строе
	на месте Y надо удалить из строя. Солдаты в строе нумеруются с нуля.
	Формат выходных данных.
	На каждую команду 1 (добавление в строй) вы должны выводить число K – номер позиции, на которую должен встать этот солдат (все стоящие за ним двигаются назад).

## Модуль 3. Алгоритмы на графах.
	* Задача 1. «Представление графа».(5 баллов)
	Дан базовый интерфейс для представления ориентированного графа:
	struct IGraph {
		virtual ~IGraph() {}
    		// Добавление ребра от from к to.
		virtual void AddEdge(int from, int to) = 0;
    		virtual int VerticesCount() const  = 0;
		virtual std::vector<int> GetNextVertices(int vertex) const = 0;
		virtual std::vector<int> GetPrevVertices(int vertex) const = 0;
	};
	Необходимо написать несколько реализаций интерфейса:
	CListGraph, хранящий граф в виде массива списков смежности,
	CMatrixGraph, хранящий граф в виде матрицы смежности,
	CSetGraph, хранящий граф в виде массива хэш-таблиц,
	CArcGraph, хранящий граф в виде одного массива пар {from, to}.
	Также необходимо реализовать конструктор, принимающий const IGraph&. Такой конструктор должен скопировать переданный граф в создаваемый объект.
	Для каждого класса создавайте отдельные h и cpp файлы.
	Число вершин графа задается в конструкторе каждой реализации.
	* Задача 2. Количество различных путей (3 балла)
	Дан невзвешенный неориентированный граф. В графе может быть несколько кратчайших путей между какими-то вершинами. Найдите количество различных
	кратчайших путей между заданными вершинами. Требуемая сложность O(V+E).
	Формат ввода.
	v: кол-во вершин (макс. 50000),
	n: кол-во ребер (макс. 200000),
	n пар реберных вершин,
	пара вершин u, w для запроса.
	Формат вывода.
	Количество кратчайших путей от u к w.
	* Задача 3. «Города» (4 балла)
	Требуется отыскать самый выгодный маршрут между городами. Требуемое время работы O((N+M)logN),
	где N-количество городов, M-известных дорог между ними.
	Формат входных данных.
	Первая строка содержит число N – количество городов.
	Вторая строка содержит число M - количество дорог.
	Каждая следующая строка содержит описание дороги (откуда, куда, время в пути).
	Последняя строка содержит маршрут (откуда и куда нужно доехать).
	Формат выходных данных.
	Вывести длину самого выгодного маршрута.
